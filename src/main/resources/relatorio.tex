\documentclass[a4paper,11pt]{article}

%Packages
\usepackage[brazilian]{babel} %Brazilian Portuguese
\usepackage[T1]{fontenc}
\usepackage{subfig}
\usepackage{color}
\usepackage[utf8]{inputenc}
\usepackage{url} %URLs
\usepackage{makeidx} %Index
\usepackage[pdftex]{graphicx} %Graphics
\usepackage{amsfonts} %Math fonts
%\usepackage{indentfirst} %Makes it indent the first paragraph of the section
\usepackage{listings} %Code support, properly highlighted
\usepackage{verbatim} %Better verbatim
%\usepackage{fancyvrb} %Fancy verbatim
\usepackage{cite} %Better citation
%\usepackage{siunitx} %SI Units 
\usepackage{hyperref} %Makes links to your references, making your life quite a bit easier.
%\usepackage[pdftex]{colortbl} %Color Tables
\usepackage{array} %Better tables - improves the algorythms
\hypersetup{ %Sets up hyperref
    %bookmarks=true,         % show bookmarks bar?
    %unicode=false,          % non-Latin characters in Acrobat?s bookmarks
    %pdftoolbar=true,        % show Acrobat?s toolbar?
    %pdfmenubar=true,        % show Acrobat?s menu?
    %pdffitwindow=false,     % window fit to page when opened
    %pdfstartview={FitH},    % fits the width of the page to the window
    pdftitle={Relatório},    % title
    %pdfauthor={Felipe Brandão Cavalcanti},     % author
    colorlinks=false,       % false: boxed links; true: colored links
    linkcolor=red,          % color of internal links
    citecolor=green,        % color of links to bibliography
    filecolor=magenta,      % color of file links
    urlcolor=cyan           % color of external links
}
\lstset{ %Sets up lisitings, so we get highlighted code
language=Java,                     % choose the language of the code
basicstyle=\footnotesize,       % the size of the fonts that are used for the code
numbers=left,                   % where to put the line-numbers
numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
stepnumber=2,                   % the step between two line-numbers. If it's 1 each line will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=single,	                % adds a frame around the code
tabsize=2,	                    % sets default tabsize to 2 spaces
captionpos=b,                   % sets the caption-position to bottom
breaklines=true,                % sets automatic line breaking
breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)}          % if you want to add a comment within your code
}


\parindent15pt  \parskip0pt
\setlength\voffset{-2.0cm}
\setlength\hoffset{-1.5cm}
\setlength\textwidth{16.0cm}
\setlength\textheight{24.5cm}
\setlength\baselineskip{2cm}
\renewcommand{\baselinestretch}{1.2}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\begin{document}
\begin{titlepage}
\begin{center}
 
% Upper part of the page
\includegraphics[width=0.25\textwidth]{./unb.pdf}\\[1cm]
 
\textsc{\LARGE Universidade de Brasília}\\[1.5cm]
 
\textsc{\Large Estrutura de Dados - Turma B - Trabalho I}\\[0.5cm]
 
% Title
\HRule \\[0.4cm]
{ \huge \bfseries Avaliação de Expressões Aritméticas\\Forma Posfixa}
\HRule
\vspace{0.75cm}
\large CIC - Departamento de Ciência da Computação\\
\vspace{0.8cm}
% Author and supervisor
\begin{minipage}{0.4\textwidth}
\begin{flushleft} \large
\emph{Autores:}\\
Tiago L. P. de Pádua - 12/1042457\\
Alex Leite\\
Ronaldo S. Ferreira Jr.\\
\end{flushleft}
\end{minipage}
\begin{minipage}{0.4\textwidth}
\begin{flushright} \large
\emph{Professor:} \\
Eduardo A. P. Alchieri
\end{flushright}
\end{minipage}
 
\vfill
 
% Bottom of the page
{\large Dezembro de 2012}
\end{center}
\end{titlepage}

\pagestyle{plain}

\begin{abstract}
Este trabalho tem o objetivo de validar, avaliar e transformar da forma infixa para a forma posfixa expressões aritméticas.
\end{abstract}

\section{Introdução} 
Dada uma expressão aritmética qualquer, inicialmente iremos realizar sua validação, verificando se todos os parênteses abertos na expressão foram devidamente fechados. A seguir, iremos converter a expressão de sua forma infixa para a forma posfixa, conforme exemplo abaixo:\\
Forma infixa: \(A*B+C-(D/E+F)\)\\
Forma posfixa: \(A B*C+D E/F+-\)

Após obtermos a forma posfixa da expressão iremos realizar sua avaliação, isto é, efetuar o cálculo da expressão e exibir seu resultado.

\section{Implementação}
A implementação foi realizada utilizando a linguagem de programação Java (javac 1.6.0\_37) através da IDE Netbeans 7.0.1.\\
As seguintes classes foram criadas:
\begin{itemize}
  \item Elemento.java
  \item Pilha.java
  \item PilhaVaziaException.java
  \item ExpressaoAritmetica.java
  \item ExpressaoGUI.java
  \item ProcessadorException.java
\end{itemize}

\subsection{Elemento.java}
Classe que serve de base para implementação de uma Pilha, possui somente os campos valor:Object e proximo:Elemento e seus métodos acessores. Como "valor" é do tipo Object, esta implamentação de pilha é genérica e servirá a qualquer tipo de dado.

\subsection{Pilha.java}
Possui os campos tamanho:int e topo:Elemento, os métodos implementados são os necessários para a utilização da pilha: 
\begin{itemize}
  \item public void empilhar(Object valor) ;
  \item public Object desempilhar() throws PilhaVaziaException;
  \item public int getTamanho();
  \item public boolean isVazio();
  \item public Object getTopo() throws PilhaVaziaException;
\end{itemize}

\subsection{PilhaVaziaException.java}
Exceção criada para identificar o erro de pilha vazia que pode ocorrer ao se tentar desempilhar de uma pilha que não tenha mais elementos.

\subsection{ExpressaoAritmetica.java}
Classe principal do programa, possui o campo expressao:String que deve ser iniciado com a expressão a ser trabalhada, são implementados os seguintes métodos:

\subsubsection{private boolean possuiCaracteresInvalidosNumericos()}
Este método retorna \(true\) caso caso a expressão aritmética numérica informada na classe possua caracteres estranhos à uma expressão aritmética numérica válida, para isso, utilizou-se uma expressão regular. 

\subsubsection{private boolean possuiCaracteresInvalidosVariaveis()}
Este método retorna \(true\) caso caso a expressão aritmética sob forma de variáveis (\(A+B*C\)) informada na classe possua caracteres estranhos à uma expressão válida, para isso, utilizou-se uma expressão regular. 

\subsubsection{public int avaliar() throws ProcessadorException}
Dada uma expressão aritmética numérida válida, este método retorna o valor resultante da expressão,  \emph{representa o requisito 3.4 do trabalho}.

\subsubsection{public void validarVariavel() throws ProcessadorException}
Valida uma expressão aritmética formada por variáveis.

\subsubsection{public void validarNumerico() throws ProcessadorException}
Valida uma expressão aritmética numérica.

\subsubsection{public static int getPrioridade(String operador) throws ProcessadorException}
Retorna a prioridade do operador aritmético informado.

\subsubsection{public static boolean isParenteses(String s)}
Retorna \(true\) caso o caracter informado seja um parêntese.

\subsubsection{public static boolean isOperador(String s)}
Retorna \(true\) caso o caracter informado seja um operador aritmético válido.

\subsubsection{public String getPosfixa(boolean comVariaveis) throws ProcessadorException}
Retorna a expressão aritmética dada para sua forma posfixa, \emph{representa o requisito 3.3 do trabalho}.

\subsubsection{public String getExpressao()}
Retorna a expressão infixa associada ao objeto.

\subsubsection{public void setExpressao(String expressao) }
Atribui ao objeto a expressão aritmética infixa a ser trabalhada.

\subsubsection{public static boolean isValorVariavel(String s)}
Verifica se o caracter apresentado representa uma variável, ou seja, uma letra do conjunto [A-Z].

\subsubsection{public boolean isExpressaoValida()}
Retorna \(true\) caso os parênteses da expressão dada estejam corretamente aninhados e balanceados, \emph{representa o requisito 3.2 do trabalho}.


\subsubsection{public String[] getVetorNumerico()}
Transforma a expressão aritmética numérica infixa em um vetor de Strings que representam cada componente da expressão.

\subsubsection{public String[] getVetorVariavel()}
Transforma a expressão aritmética com variáveis infixa em um vetor de Strings que representam cada componente da expressão.

\subsubsection{public String[] getParenteses()}
Retorna um vetor de Strings contendo todos os parenteses da expressão.

\subsubsection{public static String[] processaRegex(String regex, String s)}
Método utilitário usado para converter uma String em um vetor de Strings utilizando uma expressão regular.

\subsection{ExpressaoGUI.java}
Classe que representa a interface gráfica (GUI - Graphical User Interface), utilizada pelo usuário na execução do programa.

\subsection{ProcessadorException.java}
Exceção criada para identificar erros que decorrem do processamento da expressão aritmética.

\section{Estudo de Complexidade}
Realizaremos o estudo da complexidade dos métodos apresentados como requisitos para o trabalho, são eles:

\subsection{public boolean isExpressaoValida()}
\begin{lstlisting}
    public boolean isExpressaoValida() {
        Pilha p = new Pilha();
        String[] vetor = getParenteses();
        for (String e : vetor) {
            if ("(".equals(e)) {
                p.empilhar(e);
            } else {
                try {
                    p.desempilhar();
                } catch (PilhaVaziaException ex) {
                    return false;
                }
            }
        }
        return p.isVazio();
    }
\end{lstlisting}
Estudo da complexidade linha a linha:
\begin{itemize}
  \item Linha 2 - 1
  \item Linha 3 - 1
  \item Linha 4 - n
  \item Linha 5 - n
  \item Linha 6 - n/2
  \item Linha 7 - n/2
  \item Linha 15 - 1
\end{itemize}
Ao final teremos \(3n+3\), ou seja \(O(n)=n\).

\subsection{public String getPosfixa(boolean comVariaveis) throws ProcessadorException}
\begin{lstlisting}
    public String getPosfixa(boolean comVariaveis) throws ProcessadorException {        
        String[] vetor;       
        if(comVariaveis){
            validarVariavel();
            vetor = getVetorVariavel();
        }else{
            validarNumerico();
            vetor = getVetorNumerico();
        }       
        String resposta = "";
        Pilha pilha = new Pilha();       
        for (String e : vetor) {
            if (!comVariaveis && isValorNumerico(e)) {
                resposta += " " + e;
            }          
            if (comVariaveis && isValorVariavel(e)) {
                resposta += " " + e;
            }
            if (isOperador(e)) {
                while (!pilha.isVazio() && !isParenteses((String) pilha.getTopo()) && !(getPrioridade(e) > getPrioridade((String) pilha.getTopo()))) {
                    resposta += " " + pilha.desempilhar();
                }
                pilha.empilhar(e);
            }
            if (isParenteses(e)) {
                if ("(".equals(e)) {
                    pilha.empilhar(e);
                } else if (")".equals(e)) {
                    while (!"(".equals(pilha.getTopo())) {
                        resposta += " " + pilha.desempilhar();
                    }
                    pilha.desempilhar();
                }
            }
        }
        while (!pilha.isVazio()) {
            resposta += " " + pilha.desempilhar();
        }      
        resposta = resposta.trim();
        return resposta;
    }
\end{lstlisting}
Podemos verificar que existe apenas uma estrutura de repedição no código sem aninhamentos internos de outras estruturas de repetição, assim, concluímos que a complexidade do algoritmo é dada por \(O(n)=n\).

\subsection{public int avaliar() throws ProcessadorException}
\begin{lstlisting}
    public int avaliar() throws ProcessadorException {
        validarNumerico();        
        Pilha p = new Pilha();
        String[] vetor = processaRegex("[0-9]+|.", getPosfixa(false));
        for(String e : vetor){
            if(" ".equals(e)){
                continue;
            }            
            if(isValorNumerico(e)){
                p.empilhar(e);
            }            
            if(isOperador(e)){
                int valor1, valor2, res = 0;
                valor1 = Integer.parseInt((String)p.desempilhar());
                valor2 = Integer.parseInt((String)p.desempilhar());
                if("+".equals(e)){
                    res = valor1+valor2;
                }                
                if("-".equals(e)){
                    res = valor1-valor2;
                }                
                if("*".equals(e)){
                    res = valor1*valor2;
                }                
                if("/".equals(e)){
                    res = valor1/valor2;
                }              
                p.empilhar(Integer.toString(res));
            }
        }
        if(p.getTamanho()>1){
            throw new ProcessadorException("Erro ao processar expressao: " + getExpressao());
        }
        return Integer.parseInt((String)p.getTopo());
    }
\end{lstlisting}
Podemos verificar que existe apenas uma estrutura de repedição no código sem aninhamentos internos de outras estruturas de repetição, assim, concluímos que a complexidade do algoritmo é dada por \(O(n)=n\).

\section{Listagem de testes executados}
Para a realização dos testes, criamos a classe TesteExpressaoAritmetica.java e realizamos os testes conforme abaixo, todos foram bem sucedidos:
\begin{lstlisting}
package gov.unb.cic.ed.trabalhopilhaed;

import junit.framework.Test;
import junit.framework.TestCase;
import junit.framework.TestSuite;

public class TesteExpressaoAritmetica
        extends TestCase {

    public TesteExpressaoAritmetica(String testName) {
        super(testName);
    }

    public static Test suite() {
        return new TestSuite(TesteExpressaoAritmetica.class);
    }

    public void testExpressoes() throws ProcessadorException {
        //  Infixa                          Posfixa
        //1 (A+B*C)                         A B C * +
        //2 (A*(B+C)/D-E)                   A B C + * D / E -
        //3 (A+B*(C-D*(E-F)-G*H)-I*3)       A B C D E F - * - G H * - * + I 3 * -
        //4 (A+B*C/D*E-F)                   A B C * D / E * + F -
        //5 (A+(B-(C+(D-(E+F)))))           A B C D E F + - + - +
        //6 (A*(B+(C*(D+(E*(F+G))))))       A B C D E F G + * + * + *
        ExpressaoAritmetica e = new ExpressaoAritmetica();
        
        //1
        e.setExpressao("(A+B*C)");
        assertEquals("A B C * +", e.getPosfixa(true));
        
        //2
        e.setExpressao("(A*(B+C)/D-E)");
        assertEquals("A B C + * D / E -", e.getPosfixa(true));
        
        //3
        e.setExpressao("(A+B*(C-D*(E-F)-G*H)-I*J)");
        assertEquals("A B C D E F - * - G H * - * + I J * -", e.getPosfixa(true));
        
        //4
        e.setExpressao("(A+B*C/D*E-F)");
        assertEquals("A B C * D / E * + F -", e.getPosfixa(true));
        
        //5
        e.setExpressao("(A+(B-(C+(D-(E+F)))))");
        assertEquals("A B C D E F + - + - +", e.getPosfixa(true));
        
        //6
        e.setExpressao("(A*(B+(C*(D+(E*(F+G))))))");
        assertEquals("A B C D E F G + * + * + *", e.getPosfixa(true));                
        
    }
}

\end{lstlisting}

\section{Conclusão}
Após o término do trabalho pudemos concluir que a utilização de pilhas é recomendável quando da necessidade de algoritmos para processar expressões aritméticas, realizando a conversão de sua forma infixa para posfixa e avaliando seu resultado.
\nocite{*}					%Imprime toda a bibliografia
\bibliography{bibliografia}		
\bibliographystyle{plain}		
\end{document}